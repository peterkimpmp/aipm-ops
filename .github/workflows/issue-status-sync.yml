name: Issue Status Sync

on:
  issues:
    types: [assigned, closed, reopened]
  pull_request:
    types: [opened, closed]
  issue_comment:
    types: [created]

jobs:
  sync-labels:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: read
    steps:
      - name: Transition issue status labels
        uses: actions/github-script@v7
        with:
          script: |
            const statusLabels = [
              'status:todo', 'status:in-progress', 'status:review',
              'status:done', 'status:blocked'
            ];

            async function setStatus(issueNumber, newStatus) {
              const issue = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
              });

              const currentLabels = issue.data.labels.map(l => l.name);
              const removeLabels = currentLabels.filter(
                l => statusLabels.includes(l) && l !== newStatus
              );

              for (const label of removeLabels) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    name: label,
                  });
                } catch (e) {
                  // label may already be removed
                }
              }

              if (!currentLabels.includes(newStatus)) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: [newStatus],
                });
              }

              core.info(`#${issueNumber}: ${newStatus}`);
            }

            const event = context.eventName;
            const action = context.payload.action;

            if (event === 'issues') {
              const issueNumber = context.payload.issue.number;

              if (action === 'assigned') {
                await setStatus(issueNumber, 'status:in-progress');
              } else if (action === 'closed') {
                await setStatus(issueNumber, 'status:done');
              } else if (action === 'reopened') {
                await setStatus(issueNumber, 'status:in-progress');
              }
            }

            if (event === 'issue_comment') {
              const body = context.payload.comment.body || '';
              const issueNumber = context.payload.issue.number;
              if (/^\s*\/block\b/i.test(body)) {
                await setStatus(issueNumber, 'status:blocked');
              } else if (/^\s*\/unblock\b/i.test(body)) {
                await setStatus(issueNumber, 'status:in-progress');
              }
            }

            if (event === 'pull_request') {
              const body = context.payload.pull_request.body || '';
              const title = context.payload.pull_request.title || '';
              const text = `${title}\n${body}`;
              const refs = [...text.matchAll(/(?:Refs|Closes|Fixes)\s+#(\d+)/gi)]
                .map(m => Number(m[1]))
                .filter(n => Number.isInteger(n));
              const issueNumbers = [...new Set(refs)];

              if (issueNumbers.length === 0) return;

              if (action === 'opened') {
                for (const n of issueNumbers) {
                  await setStatus(n, 'status:review');
                }
              } else if (action === 'closed' && context.payload.pull_request.merged) {
                for (const n of issueNumbers) {
                  await setStatus(n, 'status:done');
                }
              }
            }
